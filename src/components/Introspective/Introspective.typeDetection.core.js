

composable("components.Introspective_typeDetection_core", function (require, global, internalBaseEnvironment) {


  "use strict"; // @TODO - merge the final change into other branches of this type detection module.


  /*
   *  all additional functionality this module needs
   *  is covered already by the [internalBaseEnvironment]
   *  of the "composable :: core"
   */


  var
    Trait, // the "Introspective_typeDetection_core" Trait Module.


    env_introspective = internalBaseEnvironment.introspective,


    isFunction        = env_introspective.isFunction,
    isCallable        = env_introspective.isCallable,

    isArray           = env_introspective.isArray,
    isArguments       = env_introspective.isArguments,

    isString          = env_introspective.isString,

    baseValueOf       = env_introspective.baseValueOf,


    createClassSignaturePattern = internalBaseEnvironment.helpers.createClassSignaturePattern,

    createErrorClassNamePattern = function (errorClassName) {
      return ["(?:^", errorClassName, ":)|(?:^", errorClassName, "$)|(?:\\[", errorClassName, ":\\s*name\\:\\s*", errorClassName, ")"].join("");
    },
    regX = internalBaseEnvironment.objects.regX,

    PLACEHOLDER_ERROR = "Error",

    PATTERN_CLASS_SIGNATURE_BOOLEAN = createClassSignaturePattern("Boolean"),
    PATTERN_CLASS_SIGNATURE_NUMBER  = createClassSignaturePattern("Number"),
  //PATTERN_CLASS_SIGNATURE_STRING  = createClassSignaturePattern("String"),
    PATTERN_CLASS_SIGNATURE_OBJECT  = createClassSignaturePattern("Object"),
    PATTERN_CLASS_SIGNATURE_REGEXP  = createClassSignaturePattern("RegExp"),
    PATTERN_CLASS_SIGNATURE_DATE    = createClassSignaturePattern("Date"),

    PATTERN_CLASS_SIGNATURE_ERROR   = createClassSignaturePattern(PLACEHOLDER_ERROR),

    PATTERN_CLASS_NAME_ERROR_ERROR      = createErrorClassNamePattern(PLACEHOLDER_ERROR),
    PATTERN_CLASS_NAME_EVAL_ERROR       = createErrorClassNamePattern("Eval" + PLACEHOLDER_ERROR),
    PATTERN_CLASS_NAME_RANGE_ERROR      = createErrorClassNamePattern("Range" + PLACEHOLDER_ERROR),
    PATTERN_CLASS_NAME_REFERENCE_ERROR  = createErrorClassNamePattern("Reference" + PLACEHOLDER_ERROR),
    PATTERN_CLASS_NAME_SYNTAX_ERROR     = createErrorClassNamePattern("Syntax" + PLACEHOLDER_ERROR),
    PATTERN_CLASS_NAME_TYPE_ERROR       = createErrorClassNamePattern("Type" + PLACEHOLDER_ERROR),
    PATTERN_CLASS_NAME_URI_ERROR        = createErrorClassNamePattern("URI" + PLACEHOLDER_ERROR),

    getClassSignature = env_introspective.getClassSignature,

    getErrorClassName = (function (expose_error_implementation) {
      return function (type) {

        return expose_error_implementation.call(type);
      };
    }(global[PLACEHOLDER_ERROR].prototype.toString)),


    isFinite = global.isFinite,


    NULL_VALUE = null,
    UNDEFINED_VALUE,


    isUndefined = function (type) {
      return (type === UNDEFINED_VALUE);
    },
    isDefined = function (type) {
      return (type !== UNDEFINED_VALUE);
    },
    isNull = function (type) {
      return (type === NULL_VALUE);
    },
    isNotNull = function (type) {
      return (type !== NULL_VALUE);
    },

    isUndefinedOrNull = function (type) {
      return (!type && ((type === UNDEFINED_VALUE) || (type === NULL_VALUE)));
    },
    isNeitherUndefinedNorNull = function (type) {
      return ((type !== UNDEFINED_VALUE) && (type !== NULL_VALUE));
    },


    /**
     *  returns true in case of one of the primitive ECMAScript values
     *  [boolean], [number] or [string] is this global functions argument.
     */
    isPrimitive = function (type) {
      return ((typeof type == "string") || (typeof type == "number") || (typeof type == "boolean"));
    },
    /**
     *  returns true in case of one of the primitive ECMAScript values
     *  [boolean], [number], [string] or [undefined] or [null] is this
     *  global functions argument.
     */
    isValue = function (type) {
      return (isPrimitive(type) || isUndefinedOrNull(type));
    },
    /**
     *  returns true in case of one of the ECMAScript instances of
     *  [[Boolean]], [[Number]], [[String]], [[Date]], [[Error]],
     *  [[RegExp]], [[Function]], [[Array]] or [[Object]], an object
     *  generated by a self-defined constructor function or a clients
     *  DOM-object is this global functions argument.
     */
    isObject = function (type) { // @TODO - merge the final change into other branches of this type detection module.
      // (typeof type == "function") : as for real [[Function]] types or even mozillas older [[RegExp]] implementations.
      return (!!type && ((typeof type == "object") || (typeof type == "function")));
    },


    /**
     *  returns true for every ECMAScript-conform object
     *  that is this global functions argument.
     */
    isNative = function (type) { // @TODO - merge the final change into other branches of this type detection module.
    //return (isNeitherUndefinedNorNull(type) && (typeof type.constructor == "function"));
      return (isNeitherUndefinedNorNull(type) && isFunction(type.constructor));
    },

    /**
     *  return value depends on browser implementation - for instance,
     *  in MSIE, any DOM-node is an alien so far since such an object
     *  does not support the [constructor] property (and of course the
     *  type of an objects constructor always is supposed to be "function").
     */
    isAlien = function (type) { // @TODO - merge the final change into other branches of this type detection module.
    //return (isObject(type) && (typeof type.constructor != "function"));
      return (isObject(type) && !isFunction(type.constructor));
    },/*

    4.3.6 Native Object
      A native object is any object supplied by an ECMAScript implementation independent of the host environment.
      Standard native objects are defined in this specification. Some native objects are built-in; others may be
      constructed during the course of execution of an ECMAScript program.

    4.3.7 Built-in Object
      A built-in object is any object supplied by an ECMAScript implementation, independent of the host environment,
      which is present at the start of the execution of an ECMAScript program. Standard built-in objects are defined
      in this specification, and an ECMAScript implementation may specify and define others. Every built-in object is
      a native object. A built-in constructor is a built-in object that is also a constructor.

    4.3.8 Host Object
      A host object is any object supplied by the host environment to complete the execution environment of ECMAScript.
      Any object that is not native is a host object.
*/


    isBoolean = function (type) {
      return regX.compile(PATTERN_CLASS_SIGNATURE_BOOLEAN).test(getClassSignature(type));
    },
    isBooleanValue = function (type) {
      return (typeof type == "boolean");
    },
    isBooleanObject = function (type) {
      return (isBoolean(type) && !isBooleanValue(type));
    },


    /**
     *  different order of implementing global [isNumber...] methods
     *  due to an additional validation within global [isNumber] that
     *  only will return true if number values/objects are finite too.
     */ /*
     *
     *  @TODO - merge the final changes of the whole [isNumber...] block into other branches of this type detection module.
     */
    isNumberValue = function (type) {
      return (typeof type == "number");
    },
    isNumberObject = function (type) {
      /**
       *  (typeof Number.NaN);                // "number"
       *  (typeof (new Number(Number.NaN)));  // "object"
       *  (new Number(Number.NaN));           // [NaN]
       *  (typeof Infinity);                  // "number"
       *  (typeof (new Number(Infinity)));    // "object"
       *  (new Number(Infinity));             // [Infinity]
       */
      // do not test for a finite value but test for *objectness* instead.
      return (regX.compile(PATTERN_CLASS_SIGNATURE_NUMBER).test(getClassSignature(type)) && !isNumberValue(type));
    //return (regX.compile(PATTERN_CLASS_SIGNATURE_NUMBER).test(getClassSignature(type)) && (typeof type != "number"));
    },
    isNumber = function (type) {
      // [isFinite] as of this implementation did prove its x-frame-safety.
      return ((isNumberValue(type) || isNumberObject(type)) && isFinite(type)); // additional test for a finite value.
    //return (((typeof type == "number") || isNumberObject(type)) && isFinite(type)); // additional test for a finite value.
    },/*

    or was it even better discarding above implementations
    and add an additional 4th method [isValidNumber] to
    this Traits method set?

*/ /*
    isNumber = function (type) {
      return regX.compile(PATTERN_CLASS_SIGNATURE_NUMBER).test(getClassSignature(type));
    },
    isNumberValue = function (type) {
      return (typeof type == "number");
    },
    isNumberObject = function (type) {
      return (isNumber(type) && !isNumberValue(type));
    },
    isFiniteNumber = function (type) {
      return (isNumber(type) && isFinite(type));
    },
*/


//  isString = function (type) {
//    return regX.compile(PATTERN_CLASS_SIGNATURE_STRING).test(getClassSignature(type));
//  },
    isStringValue = function (type) {
      return (typeof type == "string");
    },
    isStringObject = function (type) {
      return (isString(type) && !isStringValue(type));
    },


//  isArray     = env_introspective.isArray,
//  isArguments = env_introspective.isArguments,
    isListLike  = function (type) {
      // [isNeitherUndefinedNorNull] due to e.g. empty string values that can't be detected by truthiness/falseness.
      return (isNeitherUndefinedNorNull(type) && (typeof type.length == "number") && isFinite(type.length) && (type.length >= 0));
    },


    /**
     *  returns true only in case of this global functions argument is
     *  a native ECMAScript [[Object]] type but neither the [null] value
     *  nor an ECMAScript [[Function]] type.
     */
    isObjectObject = function (type) {
      return (isNative(type) && regX.compile(PATTERN_CLASS_SIGNATURE_OBJECT).test(getClassSignature(type)));
    },


//  isFunction  = env_introspective.isFunction,
//  isCallable  = env_introspective.isCallable,


    isRegExp = function (type) {
      return regX.compile(PATTERN_CLASS_SIGNATURE_REGEXP).test(getClassSignature(type));
    },


    isDate = function (type) {
      return regX.compile(PATTERN_CLASS_SIGNATURE_DATE).test(getClassSignature(type));
    },


    isError = function (type) {
      // [isError] : not specific - will match any error type.
      return regX.compile(PATTERN_CLASS_SIGNATURE_ERROR).test(getClassSignature(type));
    },
    isGenericError = function (type) {
      // [isErrorError] : specific - will match all [[Error]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_ERROR_ERROR).test(getErrorClassName(type))
          || (type.name === PLACEHOLDER_ERROR)
        )
      );
    },
    isEvalError = function (type) {
      // specific - will match all [[EvalError]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_EVAL_ERROR).test(getErrorClassName(type))
          || (type.name === "EvalError")
        )
      );
    },
    isRangeError = function (type) {
      // specific - will match all [[RangeError]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_RANGE_ERROR).test(getErrorClassName(type))
          || (type.name === "RangeError")
        )
      );
    },
    isReferenceError = function (type) {
      // specific - will match all [[ReferenceError]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_REFERENCE_ERROR).test(getErrorClassName(type))
          || (type.name === "ReferenceError")
        )
      );
    },
    isSyntaxError = function (type) {
      // specific - will match all [[SyntaxError]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_SYNTAX_ERROR).test(getErrorClassName(type))
          || (type.name === "SyntaxError")
        )
      );
    },
    isTypeError = function (type) {
      // specific - will match all [[TypeError]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_TYPE_ERROR).test(getErrorClassName(type))
          || (type.name === "TypeError")
        )
      );
    },
    isURIError = function (type) {
      // specific - will match all [[URIError]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_URI_ERROR).test(getErrorClassName(type))
          || (type.name === "URIError")
        )
      );
    }
  ;


  Trait = function () {

    var obj = this;


    obj.isUndefined               = isUndefined;
    obj.isDefined                 = isDefined;
    obj.isNull                    = isNull;
    obj.isNotNull                 = isNotNull;

    obj.isUndefinedOrNull         = isUndefinedOrNull;
    obj.isNeitherUndefinedNorNull = isNeitherUndefinedNorNull;


    obj.isPrimitive = isPrimitive;
    obj.isValue     = isValue;
    obj.isObject    = isObject;

    obj.isNative    = isNative;
    obj.isAlien     = isAlien;


    obj.isBoolean       = isBoolean;
    obj.isBooleanValue  = isBooleanValue;
    obj.isBooleanObject = isBooleanObject;

    obj.isNumber        = isNumber;
    obj.isNumberValue   = isNumberValue;
    obj.isNumberObject  = isNumberObject;

    obj.isString        = isString;
    obj.isStringValue   = isStringValue;
    obj.isStringObject  = isStringObject;


    obj.isArray     = isArray;
    obj.isArguments = isArguments;
    obj.isListLike  = isListLike;


    obj.isObjectObject = isObjectObject;


    obj.isFunction = isFunction;
    obj.isCallable = isCallable;


    obj.isRegExp = isRegExp;


    obj.isDate = isDate;


    obj.isError           = isError;

    obj.isGenericError    = isGenericError;
    obj.isEvalError       = isEvalError;
    obj.isRangeError      = isRangeError;
    obj.isReferenceError  = isReferenceError;
    obj.isSyntaxError     = isSyntaxError;
    obj.isTypeError       = isTypeError;
    obj.isURIError        = isURIError;


    obj.baseValueOf       = baseValueOf;
    obj.getClassSignature = getClassSignature;
  };


  return Trait;


});



/*


  [http://closure-compiler.appspot.com/home]


- Simple          - 3.045 byte
composable("components.Introspective_typeDetection_core",function(c,p,k){c=k.introspective;var l=c.isFunction,A=c.isCallable,B=c.isArray,C=c.isArguments,q=c.isString,D=c.baseValueOf,h=k.helpers.createClassSignaturePattern,e=function(a){return["(?:^",a,":)|(?:^",a,"$)|(?:\\[",a,":\\s*name\\:\\s*",a,")"].join("")},b=k.objects.regX,E=h("Boolean"),F=h("Number"),G=h("Object"),H=h("RegExp"),I=h("Date"),J=h("Error"),K=e("Error"),L=e("EvalError"),M=e("RangeError"),N=e("ReferenceError"),O=e("SyntaxError"),P=e("TypeError"),Q=e("URIError"),f=c.getClassSignature,g=function(a){return function(b){return a.call(b)}}(p.Error.prototype.toString),r=p.isFinite,R=function(a){return void 0===a},S=function(a){return void 0!==a},T=function(a){return null===a},U=function(a){return null!==a},s=function(a){return!a&&(void 0===a||null===a)},m=function(a){return void 0!==a&&null!==a},t=function(a){return"string"==typeof a||"number"==typeof a||"boolean"==typeof a},V=function(a){return t(a)||s(a)},u=function(a){return!!a&&("object"==typeof a||"function"==typeof a)},v=function(a){return m(a)&&l(a.constructor)},W=function(a){return u(a)&&!l(a.constructor)},w=function(a){return b.compile(E).test(f(a))},x=function(a){return"boolean"==typeof a},X=function(a){return w(a)&&!x(a)},n=function(a){return"number"==typeof a},y=function(a){return b.compile(F).test(f(a))&&!n(a)},Y=function(a){return(n(a)||y(a))&&r(a)},z=function(a){return"string"==typeof a},Z=function(a){return q(a)&&!z(a)},$=function(a){return m(a)&&"number"==typeof a.length&&r(a.length)&&0<=a.length},aa=function(a){return v(a)&&b.compile(G).test(f(a))},ba=function(a){return b.compile(H).test(f(a))},ca=function(a){return b.compile(I).test(f(a))},d=function(a){return b.compile(J).test(f(a))},da=function(a){return d(a)&&(b.compile(K).test(g(a))||"Error"===a.name)},ea=function(a){return d(a)&&(b.compile(L).test(g(a))||"EvalError"===a.name)},fa=function(a){return d(a)&&(b.compile(M).test(g(a))||"RangeError"===a.name)},ga=function(a){return d(a)&&(b.compile(N).test(g(a))||"ReferenceError"===a.name)},ha=function(a){return d(a)&&(b.compile(O).test(g(a))||"SyntaxError"===a.name)},ia=function(a){return d(a)&&(b.compile(P).test(g(a))||"TypeError"===a.name)},ja=function(a){return d(a)&&(b.compile(Q).test(g(a))||"URIError"===a.name)};return function(){this.isUndefined=R;this.isDefined=S;this.isNull=T;this.isNotNull=U;this.isUndefinedOrNull=s;this.isNeitherUndefinedNorNull=m;this.isPrimitive=t;this.isValue=V;this.isObject=u;this.isNative=v;this.isAlien=W;this.isBoolean=w;this.isBooleanValue=x;this.isBooleanObject=X;this.isNumber=Y;this.isNumberValue=n;this.isNumberObject=y;this.isString=q;this.isStringValue=z;this.isStringObject=Z;this.isArray=B;this.isArguments=C;this.isListLike=$;this.isObjectObject=aa;this.isFunction=l;this.isCallable=A;this.isRegExp=ba;this.isDate=ca;this.isError=d;this.isGenericError=da;this.isEvalError=ea;this.isRangeError=fa;this.isReferenceError=ga;this.isSyntaxError=ha;this.isTypeError=ia;this.isURIError=ja;this.baseValueOf=D;this.getClassSignature=f}});


*/
