

composable("components.Introspective_typeDetection_core", function (require, global, internalBaseEnvironment) {


  "use strict"; // @TODO - merge the final change into other branches of this type detection module.


  /*
   *  all additional functionality this module needs
   *  is covered already by the [internalBaseEnvironment]
   *  of the "composable :: core"
   */


  var
    Trait, // the "Introspective_typeDetection_core" Trait Module.


    env_introspective = internalBaseEnvironment.introspective,


    isFunction        = env_introspective.isFunction,
    isCallable        = env_introspective.isCallable,

    isArray           = env_introspective.isArray,
    isArguments       = env_introspective.isArguments,

    isString          = env_introspective.isString,

    baseValueOf       = env_introspective.baseValueOf,


    createClassSignaturePattern = internalBaseEnvironment.helpers.createClassSignaturePattern,

    createErrorClassNamePattern = function (errorClassName) {
      return ["(?:^", errorClassName, ":)|(?:^", errorClassName, "$)|(?:\\[", errorClassName, ":\\s*name\\:\\s*", errorClassName, ")"].join("");
    },
    regX = internalBaseEnvironment.objects.regX,

    PLACEHOLDER_ERROR = "Error",

    PATTERN_CLASS_SIGNATURE_BOOLEAN = createClassSignaturePattern("Boolean"),
    PATTERN_CLASS_SIGNATURE_NUMBER  = createClassSignaturePattern("Number"),
  //PATTERN_CLASS_SIGNATURE_STRING  = createClassSignaturePattern("String"),
    PATTERN_CLASS_SIGNATURE_OBJECT  = createClassSignaturePattern("Object"),
    PATTERN_CLASS_SIGNATURE_REGEXP  = createClassSignaturePattern("RegExp"),
    PATTERN_CLASS_SIGNATURE_DATE    = createClassSignaturePattern("Date"),

    PATTERN_CLASS_SIGNATURE_ERROR   = createClassSignaturePattern(PLACEHOLDER_ERROR),

    PATTERN_CLASS_NAME_ERROR_ERROR      = createErrorClassNamePattern(PLACEHOLDER_ERROR),
    PATTERN_CLASS_NAME_EVAL_ERROR       = createErrorClassNamePattern("Eval" + PLACEHOLDER_ERROR),
    PATTERN_CLASS_NAME_RANGE_ERROR      = createErrorClassNamePattern("Range" + PLACEHOLDER_ERROR),
    PATTERN_CLASS_NAME_REFERENCE_ERROR  = createErrorClassNamePattern("Reference" + PLACEHOLDER_ERROR),
    PATTERN_CLASS_NAME_SYNTAX_ERROR     = createErrorClassNamePattern("Syntax" + PLACEHOLDER_ERROR),
    PATTERN_CLASS_NAME_TYPE_ERROR       = createErrorClassNamePattern("Type" + PLACEHOLDER_ERROR),
    PATTERN_CLASS_NAME_URI_ERROR        = createErrorClassNamePattern("URI" + PLACEHOLDER_ERROR),

    getClassSignature = env_introspective.getClassSignature,

    getErrorClassName = (function (expose_error_implementation) {
      return function (type) {

        return expose_error_implementation.call(type);
      };
    }(global[PLACEHOLDER_ERROR].prototype.toString)),


    isFinite = global.isFinite,


    NULL_VALUE = null,
    UNDEFINED_VALUE,


    isUndefined = function (type) {
      return (type === UNDEFINED_VALUE);
    },
    isDefined = function (type) {
      return (type !== UNDEFINED_VALUE);
    },
    isNull = function (type) {
      return (type === NULL_VALUE);
    },
    isNotNull = function (type) {
      return (type !== NULL_VALUE);
    },

    isUndefinedOrNull = function (type) {
      return (type == NULL_VALUE);
    },
    isNeitherUndefinedNorNull = function (type) {
      return (type != NULL_VALUE);
    },


    /**
     *  returns true in case of one of the primitive ECMAScript values
     *  [boolean], [number] or [string] is this global functions argument.
     */
    isPrimitive = function (type) {
      return (isStringValue(type) || isNumberValue(type) || isBooleanValue(type));
    },
    /**
     *  returns true in case of one of the primitive ECMAScript values
     *  [boolean], [number], [string] or [undefined] or [null] is this
     *  global functions argument.
     */
    isValue = function (type) {
      return (isPrimitive(type) || isUndefinedOrNull(type));
    },
    /**
     *  returns true in case of one of the ECMAScript instances of
     *  [[Boolean]], [[Number]], [[String]], [[Date]], [[Error]],
     *  [[RegExp]], [[Function]], [[Array]] or [[Object]], an object
     *  generated by a self-defined constructor function or a clients
     *  DOM-object is this global functions argument.
     */
    isObject = function (type) { // @TODO - merge the final change into other branches of this type detection module.
      // (typeof type == "function") : as for real [[Function]] types or even mozillas older [[RegExp]] implementations.
      return (!!type && ((typeof type == "object") || (typeof type == "function")));
    //return (type && ((typeof type == "object") || (typeof type == "function"))); // this variant immediately returns falsy types instead of [false] value.
    },


    /**
     *  returns true for every ECMAScript-conform object
     *  that is this global functions argument.
     */
    isNative = function (type) { // @TODO - merge the final change into other branches of this type detection module.
    //return ((type != NULL_VALUE) && (typeof type.constructor == "function"));
      return (isNeitherUndefinedNorNull(type) && isFunction(type.constructor));
    },

    /**
     *  return value depends on browser implementation - for instance,
     *  in MSIE, any DOM-node is an alien so far since such an object
     *  does not support the [constructor] property (and of course the
     *  type of an objects constructor always is supposed to be "function").
     */
    isAlien = function (type) { // @TODO - merge the final change into other branches of this type detection module.
    //return (isObject(type) && (typeof type.constructor != "function"));
      return (isObject(type) && !isFunction(type.constructor));
    },/*

    4.3.6 Native Object
      A native object is any object supplied by an ECMAScript implementation independent of the host environment.
      Standard native objects are defined in this specification. Some native objects are built-in; others may be
      constructed during the course of execution of an ECMAScript program.

    4.3.7 Built-in Object
      A built-in object is any object supplied by an ECMAScript implementation, independent of the host environment,
      which is present at the start of the execution of an ECMAScript program. Standard built-in objects are defined
      in this specification, and an ECMAScript implementation may specify and define others. Every built-in object is
      a native object. A built-in constructor is a built-in object that is also a constructor.

    4.3.8 Host Object
      A host object is any object supplied by the host environment to complete the execution environment of ECMAScript.
      Any object that is not native is a host object.
*/


    isBoolean = function (type) {
      return regX.compile(PATTERN_CLASS_SIGNATURE_BOOLEAN).test(getClassSignature(type));
    },
    isBooleanValue = function (type) {
      return (typeof type == "boolean");
    },
    isBooleanObject = function (type) {
      return (isBoolean(type) && !isBooleanValue(type));
    },


    /**
     *  different order of implementing global [isNumber...] methods
     *  due to an additional validation within global [isNumber] that
     *  only will return true if number values/objects are finite too.
     */ /*
     *
     *  @TODO - merge the final changes of the whole [isNumber...] block into other branches of this type detection module.
     */
    isNumberValue = function (type) {
      return (typeof type == "number");
    },
    isNumberObject = function (type) {
      /**
       *  (typeof Number.NaN);                // "number"
       *  (typeof (new Number(Number.NaN)));  // "object"
       *  (new Number(Number.NaN));           // [NaN]
       *  (typeof Infinity);                  // "number"
       *  (typeof (new Number(Infinity)));    // "object"
       *  (new Number(Infinity));             // [Infinity]
       */
      // do not test for a finite value but test for *objectness* instead.
      return (regX.compile(PATTERN_CLASS_SIGNATURE_NUMBER).test(getClassSignature(type)) && !isNumberValue(type));
    //return (regX.compile(PATTERN_CLASS_SIGNATURE_NUMBER).test(getClassSignature(type)) && (typeof type != "number"));
    },
    isNumber = function (type) {
      // [isFinite] as of this implementation did prove its x-frame-safety.
      return ((isNumberValue(type) || isNumberObject(type)) && isFinite(type)); // additional test for a finite value.
    },/*

    or was it even better discarding above implementations
    and add an additional 4th method [isValidNumber] to
    this Traits method set?

*/ /*
    isNumber = function (type) {
      return regX.compile(PATTERN_CLASS_SIGNATURE_NUMBER).test(getClassSignature(type));
    },
    isNumberValue = function (type) {
      return (typeof type == "number");
    },
    isNumberObject = function (type) {
      return (isNumber(type) && !isNumberValue(type));
    },
    isFiniteNumber = function (type) {
      return (isNumber(type) && isFinite(type));
    },
*/


//  isString = function (type) {
//    return regX.compile(PATTERN_CLASS_SIGNATURE_STRING).test(getClassSignature(type));
//  },
    isStringValue = function (type) {
      return (typeof type == "string");
    },
    isStringObject = function (type) {
      return (isString(type) && !isStringValue(type));
    },


//  isArray     = env_introspective.isArray,
//  isArguments = env_introspective.isArguments,
    isListLike  = function (type) {
    //return (isNeitherUndefinedNorNull(type) && isNumberValue(type.length) && isFinite(type.length) && (type.length >= 0));
      return (isNeitherUndefinedNorNull(type) && isNumberValue(type = type.length) && isFinite(type) && (type >= 0)); // saves two look ups.
    },
    isRealList  = function (type) {
    //return (isListLike(type) && !isFunction(type) && type.hasOwnProperty("length") && !type.propertyIsEnumerable("length"));
      return (isListLike(type) && (typeof type != "function") && type.hasOwnProperty("length") && !type.propertyIsEnumerable("length")); // saves two look ups.
    },


    /**
     *  returns true only in case of this global functions argument is
     *  a native ECMAScript [[Object]] type but neither the [null] value
     *  nor an ECMAScript [[Function]] type.
     */
    isObjectObject = function (type) {
      return (isNative(type) && regX.compile(PATTERN_CLASS_SIGNATURE_OBJECT).test(getClassSignature(type)));
    },


//  isFunction  = env_introspective.isFunction,
//  isCallable  = env_introspective.isCallable,


    isRegExp = function (type) {
      return regX.compile(PATTERN_CLASS_SIGNATURE_REGEXP).test(getClassSignature(type));
    },


    isDate = function (type) {
      return regX.compile(PATTERN_CLASS_SIGNATURE_DATE).test(getClassSignature(type));
    },


    isError = function (type) {
      // [isError] : not specific - will match any error type.
      return regX.compile(PATTERN_CLASS_SIGNATURE_ERROR).test(getClassSignature(type));
    },
    isGenericError = function (type) {
      // [isErrorError] : specific - will match all [[Error]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_ERROR_ERROR).test(getErrorClassName(type))
          || (type.name === PLACEHOLDER_ERROR)
        )
      );
    },
    isEvalError = function (type) {
      // specific - will match all [[EvalError]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_EVAL_ERROR).test(getErrorClassName(type))
          || (type.name === "EvalError")
        )
      );
    },
    isRangeError = function (type) {
      // specific - will match all [[RangeError]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_RANGE_ERROR).test(getErrorClassName(type))
          || (type.name === "RangeError")
        )
      );
    },
    isReferenceError = function (type) {
      // specific - will match all [[ReferenceError]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_REFERENCE_ERROR).test(getErrorClassName(type))
          || (type.name === "ReferenceError")
        )
      );
    },
    isSyntaxError = function (type) {
      // specific - will match all [[SyntaxError]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_SYNTAX_ERROR).test(getErrorClassName(type))
          || (type.name === "SyntaxError")
        )
      );
    },
    isTypeError = function (type) {
      // specific - will match all [[TypeError]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_TYPE_ERROR).test(getErrorClassName(type))
          || (type.name === "TypeError")
        )
      );
    },
    isURIError = function (type) {
      // specific - will match all [[URIError]] instances.
      return (
        isError(type)
        && (
          regX.compile(PATTERN_CLASS_NAME_URI_ERROR).test(getErrorClassName(type))
          || (type.name === "URIError")
        )
      );
    }
  ;


  Trait = function () {

    var obj = this;


    obj.isUndefined               = isUndefined;
    obj.isDefined                 = isDefined;
    obj.isNull                    = isNull;
    obj.isNotNull                 = isNotNull;

    obj.isUndefinedOrNull         = isUndefinedOrNull;
    obj.isNeitherUndefinedNorNull = isNeitherUndefinedNorNull;


    obj.isPrimitive = isPrimitive;
    obj.isValue     = isValue;
    obj.isObject    = isObject;

    obj.isNative    = isNative;
    obj.isAlien     = isAlien;


    obj.isBoolean       = isBoolean;
    obj.isBooleanValue  = isBooleanValue;
    obj.isBooleanObject = isBooleanObject;

    obj.isNumber        = isNumber;
    obj.isNumberValue   = isNumberValue;
    obj.isNumberObject  = isNumberObject;

    obj.isString        = isString;
    obj.isStringValue   = isStringValue;
    obj.isStringObject  = isStringObject;


    obj.isListLike  = isListLike;
    obj.isRealList  = isRealList;
    obj.isArguments = isArguments;
    obj.isArray     = isArray;


    obj.isObjectObject = isObjectObject;


    obj.isFunction = isFunction;
    obj.isCallable = isCallable;


    obj.isRegExp = isRegExp;


    obj.isDate = isDate;


    obj.isError           = isError;

    obj.isGenericError    = isGenericError;
    obj.isEvalError       = isEvalError;
    obj.isRangeError      = isRangeError;
    obj.isReferenceError  = isReferenceError;
    obj.isSyntaxError     = isSyntaxError;
    obj.isTypeError       = isTypeError;
    obj.isURIError        = isURIError;


    obj.baseValueOf       = baseValueOf;
    obj.getClassSignature = getClassSignature;
  };


  return Trait;


});



/*


  [http://closure-compiler.appspot.com/home]


- Simple          - 3.087 byte
composable("components.Introspective_typeDetection_core",function(c,q,l){c=l.introspective;var m=c.isFunction,z=c.isCallable,A=c.isArray,B=c.isArguments,r=c.isString,C=c.baseValueOf,h=l.helpers.createClassSignaturePattern,e=function(a){return["(?:^",a,":)|(?:^",a,"$)|(?:\\[",a,":\\s*name\\:\\s*",a,")"].join("")},b=l.objects.regX,D=h("Boolean"),E=h("Number"),F=h("Object"),G=h("RegExp"),H=h("Date"),I=h("Error"),J=e("Error"),K=e("EvalError"),L=e("RangeError"),M=e("ReferenceError"),N=e("SyntaxError"),O=e("TypeError"),P=e("URIError"),f=c.getClassSignature,g=function(a){return function(b){return a.call(b)}}(q.Error.prototype.toString),s=q.isFinite,Q=function(a){return void 0===a},R=function(a){return void 0!==a},S=function(a){return null===a},T=function(a){return null!==a},U=function(a){return null==a},V=function(a){return null!=a},t=function(a){return n(a)||k(a)||p(a)},W=function(a){return t(a)||null==a},u=function(a){return!!a&&("object"==typeof a||"function"==typeof a)},v=function(a){return null!=a&&m(a.constructor)},X=function(a){return u(a)&&!m(a.constructor)},w=function(a){return b.compile(D).test(f(a))},p=function(a){return"boolean"==typeof a},Y=function(a){return w(a)&&!p(a)},k=function(a){return"number"==typeof a},x=function(a){return b.compile(E).test(f(a))&&!k(a)},Z=function(a){return(k(a)||x(a))&&s(a)},n=function(a){return"string"==typeof a},$=function(a){return r(a)&&!n(a)},y=function(a){return null!=a&&k(a=a.length)&&s(a)&&0<=a},aa=function(a){return y(a)&&"function"!=typeof a&&a.hasOwnProperty("length")&&!a.propertyIsEnumerable("length")},ba=function(a){return v(a)&&b.compile(F).test(f(a))},ca=function(a){return b.compile(G).test(f(a))},da=function(a){return b.compile(H).test(f(a))},d=function(a){return b.compile(I).test(f(a))},ea=function(a){return d(a)&&(b.compile(J).test(g(a))||"Error"===a.name)},fa=function(a){return d(a)&&(b.compile(K).test(g(a))||"EvalError"===a.name)},ga=function(a){return d(a)&&(b.compile(L).test(g(a))||"RangeError"===a.name)},ha=function(a){return d(a)&&(b.compile(M).test(g(a))||"ReferenceError"===a.name)},ia=function(a){return d(a)&&(b.compile(N).test(g(a))||"SyntaxError"===a.name)},ja=function(a){return d(a)&&(b.compile(O).test(g(a))||"TypeError"===a.name)},ka=function(a){return d(a)&&(b.compile(P).test(g(a))||"URIError"===a.name)};return function(){this.isUndefined=Q;this.isDefined=R;this.isNull=S;this.isNotNull=T;this.isUndefinedOrNull=U;this.isNeitherUndefinedNorNull=V;this.isPrimitive=t;this.isValue=W;this.isObject=u;this.isNative=v;this.isAlien=X;this.isBoolean=w;this.isBooleanValue=p;this.isBooleanObject=Y;this.isNumber=Z;this.isNumberValue=k;this.isNumberObject=x;this.isString=r;this.isStringValue=n;this.isStringObject=$;this.isListLike=y;this.isRealList=aa;this.isArguments=B;this.isArray=A;this.isObjectObject=ba;this.isFunction=m;this.isCallable=z;this.isRegExp=ca;this.isDate=da;this.isError=d;this.isGenericError=ea;this.isEvalError=fa;this.isRangeError=ga;this.isReferenceError=ha;this.isSyntaxError=ia;this.isTypeError=ja;this.isURIError=ka;this.baseValueOf=C;this.getClassSignature=f}});


*/
